package de.rbsulm.rbs_lf12.controllers;

import de.rbsulm.rbs_lf12.model.CalendarCategory;
import de.rbsulm.rbs_lf12.model.CalendarEvent;
import de.rbsulm.rbs_lf12.model.ThymeCalendarEvent;
import de.rbsulm.rbs_lf12.model.User;
import de.rbsulm.rbs_lf12.mysql.CalendarCategoryRepository;
import de.rbsulm.rbs_lf12.mysql.CalendarEventRepository;
import de.rbsulm.rbs_lf12.mysql.UserRepository;
import de.rbsulm.rbs_lf12.services.EmailService;
import de.rbsulm.rbs_lf12.services.SchedulerService;
import org.quartz.SchedulerException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Sort;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.stream.Collectors;

@Controller // This means that this class is a Controller
@RequestMapping(path="/calendarEvent") // This means URL's start with /calendarEvent (after Application path)
public class CalendarEventController {
  @Autowired // This means to get the bean called userRepository
         // Which is auto-generated by Spring, we will use it to handle the data
  private CalendarEventRepository calendarEventRepository;
  @Autowired
  private CalendarCategoryRepository calendarCategoryRepository;
  @Autowired
  private UserRepository userRepository;
  @Autowired
  private SchedulerService schedulerService;
  @Autowired
  private EmailService emailService;

  @GetMapping("/show/{day}")
  public String calendarEvents(Model model, @PathVariable int day) {
    final LocalDateTime now = LocalDateTime.now();
    final LocalDateTime dayDTStart = now.minusDays(now.getDayOfMonth()).plusDays(day).toLocalDate().atStartOfDay();
    final LocalDateTime dayDTEnd = dayDTStart.plusDays(1).toLocalDate().atStartOfDay();
    final List<CalendarEvent> calendarEventList = calendarEventRepository.getCalendarEventsByStartDateAfterAndStartDateBefore(dayDTStart.toEpochSecond(ZoneOffset.UTC) * 1000, dayDTEnd.toEpochSecond(ZoneOffset.UTC) * 1000);
    calendarEventList.sort(Comparator.comparing(CalendarEvent::getStartDate));
    final List<CalendarEvent> filterdList = calendarEventList.stream().filter(it -> Objects.equals(it.getUser().getId(), HomeController.getCurrentUser(userRepository).getId())).toList();
    HomeController.defaultSiteSetup(model, userRepository).addAttribute("events", filterdList.stream().map(ThymeCalendarEvent::new).toList());
    return "events";
  }
  /*@GetMapping(path = "/event/{id}")
  public String event(Model model, @PathVariable int id) {
    final Optional<CalendarEvent> user = calendarEventRepository.findById(id);
    user.ifPresent(value -> HomeController.defaultSiteSetup(model).addAttribute("event", value));
    return "event";
  }*/

  @GetMapping(path = "/edit/{id}")
  public String edit(Model model, @PathVariable int id) {
    final Optional<CalendarEvent> user = calendarEventRepository.findById(id);
    user.ifPresent(value -> HomeController.defaultSiteSetup(model, userRepository).addAttribute("user", value)
            .addAttribute("categories", calendarCategoryRepository.findAll()));
    return "editEvent";
  }
  @PostMapping(path = "/edit")
  public String edit(Model model, @ModelAttribute() CalendarEvent calendarEvent) {
    HomeController.defaultSiteSetup(model, userRepository).addAttribute("event", calendarEvent);
    calendarEventRepository.save(calendarEvent);
    return "editUserResult";
  }

  @GetMapping("/newEvent")
  public String newEvent(Model model){
    HomeController.defaultSiteSetup(model, userRepository).addAttribute("event", new ThymeCalendarEvent())
            .addAttribute("categories", calendarCategoryRepository.findAll());
    return "newEvent";
  }

  @PostMapping(path="/newEvent") // Map ONLY POST Requests
  public String NewEvent(@ModelAttribute ThymeCalendarEvent event, Model model) {
    final CalendarEvent newEvent = new CalendarEvent();
    final DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");
    final LocalDateTime ldt = LocalDateTime.parse(event.getStartDate().replace("T", " "), formatter);
    newEvent.setTitle(event.getTitle());
    newEvent.setDescription(event.getDescription());
    newEvent.setLocation(event.getLocation());
    newEvent.setStartDate(ldt.toEpochSecond(ZoneOffset.UTC) * 1000);
    newEvent.setCategory(event.getCategory());
    newEvent.setUser(HomeController.getCurrentUser(userRepository));
    HomeController.defaultSiteSetup(model, userRepository).addAttribute("event", newEvent)
            .addAttribute("dateTime", event.getStartDate().replace("T" , " "));
    calendarEventRepository.save(newEvent);
    if (ldt.minusDays(1).isAfter(LocalDateTime.now())) {
      try {
        schedulerService.schedule(ldt.minusDays(1),
                () -> {
                    System.out.println("calendar email send");
                    //todo emailService.sendMail("", event.getTitle() + " " + event.getLocation(), event.getDescription());
                });

      }catch (SchedulerException e){
        e.printStackTrace();
      }
    }

    return "newEventResult";
  }
  @GetMapping("/newCategory")
  public String newCategory(Model model){
    HomeController.defaultSiteSetup(model, userRepository).addAttribute("category", new CalendarCategory());
    return "newCategory";
  }

  @PostMapping(path="/newCategory") // Map ONLY POST Requests
  public String newCategory(@ModelAttribute CalendarCategory category, Model model) {
    HomeController.defaultSiteSetup(model, userRepository).addAttribute("category", category);

    calendarCategoryRepository.save(category);
    return "newCategoryResult";
  }

  @GetMapping(path = "/calendar")
  public String calendar(Model model){
    final LocalDateTime now = LocalDateTime.now();
    final LocalDateTime startOfMonth = now.minusDays(now.getDayOfMonth());
    final LocalDateTime endOfMonth = startOfMonth.plusDays(startOfMonth.getMonth().maxLength());
    final List<CalendarEvent> calendarEventList = new ArrayList<>(calendarEventRepository.getCalendarEventsByStartDateAfterAndStartDateBefore(startOfMonth.toEpochSecond(ZoneOffset.UTC) * 1000, endOfMonth.toEpochSecond(ZoneOffset.UTC) * 1000)
            .stream().filter(it -> Objects.equals(it.getUser().getId(), HomeController.getCurrentUser(userRepository).getId())).toList());
    calendarEventList.sort(Comparator.comparing(CalendarEvent::getStartDate));
    final Map<Integer, List<CalendarEvent>> eventMap = new HashMap<Integer, List<CalendarEvent>>();
    calendarEventList.forEach(calendarEvent -> {
      final int day = LocalDateTime.ofEpochSecond(calendarEvent.getStartDate() / 1000, (int)(calendarEvent.getStartDate() % 1000), ZoneOffset.UTC).getDayOfMonth();
      if (!eventMap.containsKey(day)) {
        eventMap.put(day, List.of(calendarEvent));
      }else{
        eventMap.get(day).add(calendarEvent);
      }
    });
    for (int i = 1; i <= now.getMonth().maxLength(); i++) {
      if (!eventMap.containsKey(i)) {
        eventMap.put(i, new ArrayList<>());
      }
    }
    HomeController.defaultSiteSetup(model, userRepository).addAttribute("events", eventMap);
    return "calendar";
  }
}
